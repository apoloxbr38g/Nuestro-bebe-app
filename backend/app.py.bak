# backend/app.py
from __future__ import annotations

# ========= Imports base =========
from fastapi import FastAPI, Query, Body, HTTPException, Depends
from fastapi.responses import JSONResponse, HTMLResponse, RedirectResponse, FileResponse
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel

import os
import time
import math
import json
import hmac
import hashlib
from pathlib import Path
from typing import List, Optional

import pandas as pd
import numpy as np
import joblib
from dotenv import load_dotenv
import httpx
from datetime import date, timedelta, datetime

# ========= Parche XGBoost legacy =========
def _patch_legacy_xgb_bundle(bundle):
    """Evita errores de compatibilidad entre versiones de XGBoost."""
    if bundle is None:
        return None
    mdl = bundle.get("model") if isinstance(bundle, dict) else bundle
    try:
        if not hasattr(mdl, "use_label_encoder"):
            setattr(mdl, "use_label_encoder", False)
        if not hasattr(mdl, "predictor"):
            setattr(mdl, "predictor", None)
        if not hasattr(mdl, "gpu_id"):
            setattr(mdl, "gpu_id", None)
    except Exception as e:
        print("[WARN] No pude parchear modelo XGB:", repr(e))
    return bundle

# ========= .env y claves proveedor =========
load_dotenv()

APISPORTS_KEY    = os.getenv("APISPORTS_KEY")
APIFOOTBALL_KEY  = os.getenv("APIFOOTBALL_API_KEY")

APISPORTS_BASE   = os.getenv("APISPORTS_BASE", "https://v3.football.api-sports.io")
APIFOOTBALL_BASE = os.getenv("APIFOOTBALL_BASE", "https://apiv3.apifootball.com/")

# ========= Auth / Users =========
try:
    import jwt  # PyJWT
except ImportError:
    jwt = None

USERS_DB_PATH = Path(__file__).parent / "data" / "users.json"
USERS_DB_PATH.parent.mkdir(parents=True, exist_ok=True)

JWT_SECRET   = os.getenv("JWT_SECRET", "change-me")
JWT_ALG      = "HS256"
JWT_TTL_MIN  = 24 * 60  # 24h

def _hash(password: str) -> str:
    return hmac.new(JWT_SECRET.encode(), password.encode(), hashlib.sha256).hexdigest()

def _env_users():
    out = {}
    admin_user = os.getenv("ADMIN_USER")
    admin_pass = os.getenv("ADMIN_PASS")
    if admin_user and admin_pass:
        out[admin_user] = {"role": "admin", "password_hash": _hash(admin_pass)}
    user_user = os.getenv("USER_USER")
    user_pass = os.getenv("USER_PASS")
    if user_user and user_pass:
        out[user_user] = {"role": "user", "password_hash": _hash(user_pass)}
    for key, val in os.environ.items():
        if key.endswith("_USER"):
            prefix = key[:-5]
            u = val.strip()
            p = os.getenv(prefix + "_PASS", "").strip()
            r = os.getenv(prefix + "_ROLE", "").strip().lower()
            if u and p:
                role = r if r in ("admin", "user") else ("admin" if prefix.startswith("ADMIN") else "user")
                out[u] = {"role": role, "password_hash": _hash(p)}
    return out

def _load_users_file():
    if USERS_DB_PATH.exists():
        try:
            with open(USERS_DB_PATH, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            pass
    return {}

def _save_users_file(db: dict):
    with open(USERS_DB_PATH, "w", encoding="utf-8") as f:
        json.dump(db, f, ensure_ascii=False, indent=2)

class UserStore:
    def __init__(self):
        self.db = _env_users()
        file_db = _load_users_file()
        self.db.update(file_db)
        self._persist()

    def _persist(self):
        _save_users_file(self.db)

    def list_public(self):
        return [{"username": u, "role": v["role"]} for u, v in sorted(self.db.items())]

    def add(self, username: str, password: str, role: str):
        username = username.strip()
        role = role.strip().lower()
        if role not in ("admin", "user"):
            raise ValueError("Rol inv√°lido (usa 'admin' o 'user').")
        if not username or not password:
            raise ValueError("Usuario y contrase√±a requeridos.")
        if username in self.db:
            raise ValueError("El usuario ya existe.")
        self.db[username] = {"role": role, "password_hash": _hash(password)}
        self._persist()

    def delete(self, username: str):
        if username in self.db:
            del self.db[username]
            self._persist()
        else:
            raise ValueError("Usuario no existe.")

    def verify(self, username: str, password: str) -> dict | None:
        rec = self.db.get(username)
        if not rec:
            return None
        return rec if _hash(password) == rec["password_hash"] else None

USERS = UserStore()

def _require_pyjwt():
    if jwt is None:
        raise RuntimeError("Falta PyJWT. Instala con: pip install PyJWT")

def make_token(username: str, role: str) -> str:
    _require_pyjwt()
    now = datetime.utcnow()
    payload = {
        "sub": username,
        "role": role,
        "iat": int(now.timestamp()),
        "nbf": int((now - timedelta(seconds=5)).timestamp()),  # margen
        "exp": int((now + timedelta(minutes=JWT_TTL_MIN)).timestamp()),
    }
    return jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALG)

def decode_token(token: str) -> dict:
    _require_pyjwt()
    return jwt.decode(
        token,
        JWT_SECRET,
        algorithms=[JWT_ALG],
        leeway=60,
        options={"verify_iat": False},
    )

http_bearer = HTTPBearer(auto_error=True)

def get_current_user(creds: HTTPAuthorizationCredentials = Depends(http_bearer)):
    try:
        data = decode_token(creds.credentials)
        return {"username": data["sub"], "role": data["role"]}
    except Exception:
        raise HTTPException(status_code=401, detail="Token inv√°lido o expirado.")

def admin_required(user=Depends(get_current_user)):
    if user["role"] != "admin":
        raise HTTPException(status_code=403, detail="Solo admin.")
    return user

def user_required(user=Depends(get_current_user)):
    if user["role"] not in ("user", "admin"):
        raise HTTPException(status_code=403, detail="Solo usuarios autenticados.")
    return user

# ========= CREA APP =========
app = FastAPI(
    title="Nuestro Beb√© App",
    version="0.8.1",
    swagger_ui_parameters={"defaultModelsExpandDepth": -1},
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# ========= Endpoints de Auth =========
class LoginRequest(BaseModel):
    username: str
    password: str

class LoginResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"
    role: str

@app.post("/auth/login", response_model=LoginResponse)
def login(body: LoginRequest):
    user = USERS.verify(body.username, body.password)
    if not user:
        raise HTTPException(status_code=401, detail="Credenciales inv√°lidas")
    token = make_token(body.username, user["role"])
    return LoginResponse(access_token=token, role=user["role"])

@app.get("/auth/me")
def auth_me(user=Depends(get_current_user)):
    return {"username": user["username"], "role": user["role"]}

class UserIn(BaseModel):
    username: str
    password: str
    role: str  # "admin" | "user"

@app.get("/users")
def list_users(_: dict = Depends(admin_required)):
    return USERS.list_public()

@app.post("/users")
def add_user(body: UserIn, _: dict = Depends(admin_required)):
    try:
        USERS.add(body.username, body.password, body.role)
        return {"ok": True}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.delete("/users/{username}")
def delete_user(username: str, _: dict = Depends(admin_required)):
    try:
        USERS.delete(username)
        return {"ok": True}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

# ========= Imports del proyecto =========
from backend.providers import apisports
from backend.models.baseline import PoissonModel
from backend.data_loader import refresh_dataset, MERGED
from backend.train import MODEL_PATH
from backend.train_ou import MODEL_OU_PATH
from backend.train_btts import MODEL_BTTS_PATH
from backend.models.features import build_training_table
from backend.utils.data_loader import load_league_history

# ========= Config ligas =========
DEFAULT_SEASONS: List[str] = ["2526", "2425", "2324", "2223", "2122"]
SUPPORTED_LEAGUES = {
    "SP1": "LaLiga (Primera)", "SP2": "LaLiga (Segunda)",
    "E0": "Premier League", "E1": "Championship",
    "D1": "Bundesliga", "D2": "2. Bundesliga",
    "I1": "Serie A", "I2": "Serie B",
    "F1": "Ligue 1", "F2": "Ligue 2",
    "N1": "Eredivisie", "P1": "Primeira Liga",
    "SC0": "Scottish Premiership", "B1": "Belgian First Division A",
    "T1": "Superliga Turqu√≠a", "J1": "J1 League (Jap√≥n)",
    "G1": "Superliga Grecia", "UKR": "Liga Premier Ucrania",
}

# ========= Cache/estado =========
df_global: Optional[pd.DataFrame] = None
Xy_global: Optional[pd.DataFrame] = None
current_csv_path: Optional[Path] = None

model = PoissonModel()
clf_bundle = None
clf_ou_bundle = None
clf_btts_bundle = None

# ========= Paths =========
LOCAL_SAMPLE = Path(__file__).parent / "data" / "sample_matches.csv"
DATA_PATH = MERGED if MERGED.exists() else LOCAL_SAMPLE

# ========= Frontend est√°tico =========
FRONT_DIR = Path(__file__).parent.parent / "frontend"
app.mount("/app", StaticFiles(directory=str(FRONT_DIR), html=True), name="frontend")
app.mount("/assets", StaticFiles(directory=str(FRONT_DIR / "assets")), name="assets")
app.mount("/app/assets", StaticFiles(directory=str(FRONT_DIR / "assets")), name="assets_app")

# ========= Helpers internos =========
def _set_data(df: pd.DataFrame, csv_path: Path | None = None, build_features: bool = True):
    global df_global, Xy_global, current_csv_path, model
    df_global = df.copy()
    current_csv_path = csv_path
    model.fit(df_global)
    if build_features:
        try:
            Xy_global = build_training_table(df_global, window=10)
        except Exception as e:
            Xy_global = None
            print("[WARN] build_training_table fall√≥:", e)

def _ensure_data_loaded():
    global df_global
    if df_global is None:
        df = pd.read_csv(DATA_PATH)
        _set_data(df, DATA_PATH, build_features=False)

def _ensure_features():
    global Xy_global, df_global
    if Xy_global is None and df_global is not None:
        Xy_global = build_training_table(df_global, window=10)

def _get_Xy():
    _ensure_data_loaded()
    _ensure_features()
    return Xy_global if Xy_global is not None else build_training_table(df_global, window=10)

def _col_ok(df, c):
    return (c in df.columns) and (df[c].notna().sum() > 0)

def _recent_mean_home(df, team, col, n=10):
    if not _col_ok(df, col): return None
    d = df.loc[df["HomeTeam"] == team, col].dropna().tail(n)
    return float(d.mean()) if len(d) else None

def _recent_mean_away(df, team, col, n=10):
    if not _col_ok(df, col): return None
    d = df.loc[df["AwayTeam"] == team, col].dropna().tail(n)
    return float(d.mean()) if len(d) else None

def _sum_opt(a, b):
    if a is None and b is None: return None
    return (a or 0.0) + (b or 0.0)

def _poisson_cdf(k, lam):
    if lam is None: return None
    k = int(k)
    s = 0.0
    for i in range(0, k+1):
        s += math.exp(-lam) * (lam**i) / math.factorial(i)
    return s

def _poisson_pmf(k, lam):
    if lam is None: return None
    return math.exp(-lam) * (lam**k) / math.factorial(k)

def _clip01(x):
    if x is None: return None
    return max(0.0, min(1.0, float(x)))

def _safe_ts(dt_str: str) -> int:
    try:
        return int(datetime.fromisoformat(dt_str.replace(" ", "T")).timestamp())
    except Exception:
        return 0

def _to_int(s):
    try:
        return int(s) if s is not None and str(s).strip() != "" else None
    except Exception:
        return None

# ========= Response Models =========
class PredictResponse(BaseModel):
    home: str
    away: str
    p_home: float
    p_draw: float
    p_away: float
    exp_goals_home: float
    exp_goals_away: float
    exp_goals_total: float
    ou_over25: float
    ou_under25: float
    btts_yes: float
    btts_no: float
    top_scorelines: list
    src_1x2: str
    src_ou25: str
    src_btts: str
    # extras
    exp_corners_home: float | None = None
    exp_corners_away: float | None = None
    exp_corners_total: float | None = None
    corners_over95: float | None = None
    corners_under95: float | None = None
    exp_yellows_home: float | None = None
    exp_yellows_away: float | None = None
    exp_yellows_total: float | None = None
    yellows_over45: float | None = None
    yellows_under45: float | None = None
    exp_reds_home: float | None = None
    exp_reds_away: float | None = None
    exp_reds_total: float | None = None
    p_goals_0: float | None = None
    p_goals_1: float | None = None
    p_goals_2: float | None = None
    p_goals_3plus: float | None = None

class NationalPredictIn(BaseModel):
    home_id: int
    away_id: int
    neutral: bool = False
    lookback: int = 10

# ========= Startup =========
@app.on_event("startup")
def _load_and_train():
    global clf_bundle, clf_ou_bundle, clf_btts_bundle
    try:
        df = pd.read_csv(DATA_PATH)
    except Exception:
        df = pd.read_csv(LOCAL_SAMPLE)
    _set_data(df, DATA_PATH, build_features=False)

    clf_bundle      = joblib.load(MODEL_PATH)      if MODEL_PATH.exists()      else None
    clf_ou_bundle   = joblib.load(MODEL_OU_PATH)   if MODEL_OU_PATH.exists()   else None
    clf_btts_bundle = joblib.load(MODEL_BTTS_PATH) if MODEL_BTTS_PATH.exists() else None

    clf_bundle      = _patch_legacy_xgb_bundle(clf_bundle)
    clf_ou_bundle   = _patch_legacy_xgb_bundle(clf_ou_bundle)
    clf_btts_bundle = _patch_legacy_xgb_bundle(clf_btts_bundle)

    _ensure_data_loaded()
    _ensure_features()
    print("üíú Warmup completado: features precargadas.")

# ========= Entrenamientos =========
@app.post("/train")
def train_endpoint(_: dict = Depends(admin_required)):
    from backend.train import train as _train
    info = _train(str(DATA_PATH))
    global clf_bundle
    clf_bundle = joblib.load(MODEL_PATH) if MODEL_PATH.exists() else None
    return {"status": "ok", **info}

@app.post("/train_ou")
def train_ou_endpoint(_: dict = Depends(admin_required)):
    from backend.train_ou import train_ou as _train_ou
    info = _train_ou(str(DATA_PATH))
    global clf_ou_bundle
    clf_ou_bundle = joblib.load(MODEL_OU_PATH) if MODEL_OU_PATH.exists() else None
    return {"status": "ok", **info}

@app.post("/train_btts")
def train_btts_endpoint(_: dict = Depends(admin_required)):
    from backend.train_btts import train_btts as _train_btts
    info = _train_btts(str(DATA_PATH))
    global clf_btts_bundle
    clf_btts_bundle = joblib.load(MODEL_BTTS_PATH) if MODEL_BTTS_PATH.exists() else None
    return {"status": "ok", **info}

# ========= Recargas CSV =========
@app.post("/reload")
def reload_data(
    build_features: bool = Body(False, embed=True),
    _: dict = Depends(admin_required),
):
    path = refresh_dataset(leagues=("SP1",), start_years=(2023, 2024))
    df = pd.read_csv(path)
    _set_data(df, Path(path), build_features=build_features)
    return {"status": "ok", "rows": int(len(df)), "file": str(path), "built": build_features}

@app.post("/reload_multi")
def reload_multi(
    leagues: List[str] = Body(..., embed=True),
    start_years: Optional[List[int]] = Body(None, embed=True),
    last_n: Optional[int] = Body(4, embed=True),
    build_features: bool = Body(False, embed=True),
    _: dict = Depends(admin_required),
):
    kwargs = {}
    if start_years:
        kwargs["start_years"] = tuple(start_years)
        kwargs["last_n_years"] = None
    else:
        kwargs["start_years"] = tuple()
        kwargs["last_n_years"] = int(last_n or 4)

    path = refresh_dataset(leagues=tuple(leagues), **kwargs)
    df = pd.read_csv(path)
    _set_data(df, Path(path), build_features=build_features)
    return {
        "status": "ok",
        "rows": int(len(df)),
        "file": str(path),
        "leagues": leagues,
        "years": (start_years if start_years else f"last_{last_n}"),
        "built": build_features,
    }

# ========= Proveedor: ApiSports / Apifootball =========
@app.get("/providers/ping")
async def providers_ping():
    return {
        "apisports_key_loaded": bool(APISPORTS_KEY),
        "apifootball_key_loaded": bool(APIFOOTBALL_KEY),
    }

@app.get("/leagues/by-country")
async def leagues_by_country(country: str = Query(..., description="Ej: Turkey, Ukraine, Japan, Greece, China")):
    leagues = await apisports.leagues_by_country(country)
    return {"country": country, "leagues": leagues}

@app.get("/fixtures/by-league")
async def fixtures_by_league(
    league_id: str = Query(..., description="ID de liga ApiSports (p.ej. 39)"),
    season: int | None = Query(None),
    date_: str | None = Query(None, alias="date"),
    next_: int | None = Query(None, alias="next"),
    days: int | None = Query(30),
):
    if next_ is not None and (date_ or days not in (None, 30) or season is not None):
        raise HTTPException(status_code=400, detail="Usa 'next' solo, o usa 'date/season/days' sin 'next'.")
    fixtures = await apisports.fixtures_by_league(league_id, season=season, date=date_, next=next_, days=days or 30)
    return {"count": len(fixtures), "fixtures": fixtures}

@app.get("/fixtures/global_next5")
async def fixtures_global_next5(tz: str = "America/Santiago", days: int = 14):
    if not APIFOOTBALL_KEY:
        raise HTTPException(status_code=500, detail="Falta APIFOOTBALL_API_KEY")

    start = date.today()
    end   = start + timedelta(days=max(1, min(days, 30)))

    params = {
        "APIkey": APIFOOTBALL_KEY,
        "action": "get_events",
        "from": start.isoformat(),
        "to":   end.isoformat(),
        "timezone": tz,
    }

    async with httpx.AsyncClient(timeout=40.0) as cx:
        r = await cx.get(APIFOOTBALL_BASE, params=params)
        r.raise_for_status()
        data = r.json()

    if not isinstance(data, list):
        return {"count": 0, "fixtures": []}

    items = []
    for it in data:
        items.append({
            "datetime": f"{it.get('match_date','')} {it.get('match_time','')}".strip(),
            "league":   it.get("league_name") or "",
            "home":     it.get("match_hometeam_name") or "",
            "away":     it.get("match_awayteam_name") or "",
            "status":   it.get("match_status") or "",
        })

    items.sort(key=lambda x: x["datetime"])
    return {"count": min(5, len(items)), "fixtures": items[:5]}

# ========= Top Scorers (ApiSports) =========
CODE_TO_ID = {"E0": 39, "SP1": 140, "I1": 135, "D1": 78, "F1": 61}

@app.get("/topscorers")
async def topscorers(
    league: Optional[str] = Query(None, description="C√≥digo tipo E0, SP1‚Ä¶"),
    league_id: Optional[int] = Query(None, description="ID ApiSports"),
    season: Optional[int] = Query(None, description="A√±o inicio temporada (ej 2024)"),
):
    if not APISPORTS_KEY:
        raise HTTPException(status_code=500, detail="Falta APISPORTS_KEY")

    if league_id is None:
        if not league:
            raise HTTPException(status_code=422, detail="Manda league_id num√©rico o league (c√≥digo).")
        code = league.upper()
        if code not in CODE_TO_ID:
            raise HTTPException(status_code=400, detail=f"C√≥digo de liga no soportado: {code}")
        league_id = CODE_TO_ID[code]

    if season is None:
        season = date.today().year

    url = f"{APISPORTS_BASE}/players/topscorers"
    headers = {"x-apisports-key": APISPORTS_KEY}

    async def _fetch(season_year: int):
        params = {"league": league_id, "season": season_year}
        async with httpx.AsyncClient(timeout=40.0) as cx:
            r = await cx.get(url, headers=headers, params=params)
            r.raise_for_status()
            return r.json()

    payload = await _fetch(season)
    resp = payload.get("response") or []
    if not resp and season > 2000:
        payload = await _fetch(season - 1)
        resp = payload.get("response") or []

    items = []
    for it in resp:
        player = it.get("player") or {}
        stats  = (it.get("statistics") or [{}])[0]
        team   = (stats.get("team") or {})
        goals  = (stats.get("goals") or {}).get("total")
        items.append({
            "player_name": player.get("name") or f"{player.get('firstname','')} {player.get('lastname','')}".strip(),
            "photo": player.get("photo"),
            "team_name": team.get("name"),
            "goals": goals or 0,
            "player": player,
            "statistics": it.get("statistics"),
            "team": team,
        })
    return {"count": len(items), "players": items}

# ========= √öltimos resultados (APIFOOTBALL) =========
@app.get("/recent_live")
async def recent_live(days: int = 8, limit: int = 10):
    if not APIFOOTBALL_KEY:
        raise HTTPException(status_code=500, detail="Falta APIFOOTBALL_API_KEY")

    start = date.today() - timedelta(days=max(1, min(days, 30)))
    end   = date.today()
    params = {
        "APIkey": APIFOOTBALL_KEY,
        "action": "get_events",
        "from": start.isoformat(),
        "to":   end.isoformat(),
        "timezone": "UTC",
    }
    try:
        async with httpx.AsyncClient(timeout=40.0) as cx:
            r = await cx.get(APIFOOTBALL_BASE, params=params)
            r.raise_for_status()
            data = r.json()
    except Exception as e:
        raise HTTPException(status_code=502, detail=f"Proveedor fall√≥: {e}")

    if not isinstance(data, list):
        return {"matches": []}

    FINISHED_KEYS = {"finished","ft","ended","match finished","after extra time","aet","after penalties","ap"}
    EXCLUDE_KEYS  = {"postponed","canceled","cancelled","abandoned","walkover"}

    items = []
    for it in data:
        dt = f"{it.get('match_date','')} {it.get('match_time','')}".strip()
        home_ft = it.get("match_hometeam_ft_score")
        away_ft = it.get("match_awayteam_ft_score")
        if home_ft is None and away_ft is None:
            home_ft = it.get("match_hometeam_score")
            away_ft = it.get("match_awayteam_score")

        raw_status = (it.get("match_status") or "").strip()
        status_norm = raw_status.lower()
        is_finished = (
            status_norm in FINISHED_KEYS or
            (_to_int(home_ft) is not None and _to_int(away_ft) is not None and status_norm not in EXCLUDE_KEYS)
        )
        if not is_finished:
            continue

        items.append({
            "Date":     dt.split(" ")[0] if dt else "",
            "League":   it.get("league_name") or "",
            "HomeTeam": it.get("match_hometeam_name") or "",
            "AwayTeam": it.get("match_awayteam_name") or "",
            "FTHG":     _to_int(home_ft),
            "FTAG":     _to_int(away_ft),
            "ts":       _safe_ts(dt),
        })

    items.sort(key=lambda x: x.get("ts", 0), reverse=True)
    items = items[:max(1, min(limit, 50))]
    for it in items:
        it.pop("ts", None)
    return {"matches": items}

# ========= Selecciones (nacionales) =========
@app.get("/teams/national")
async def teams_national(q: Optional[str] = Query(None, description="Filtro: 'Chile', 'Argentina', 'Bra'‚Ä¶")):
    try:
        if q and q.strip():
            teams = await apisports.teams_national_search_smart(q.strip())
        else:
            teams = await apisports.teams_national_search("a")
        return {"count": len(teams), "teams": teams}
    except Exception as e:
        print("[/teams/national] ERROR:", repr(e))
        return JSONResponse(status_code=200, content={"count": 0, "teams": [], "error": str(e)})

class _PredictPayload(BaseModel):
    pass

# ========= Datos locales para UI =========
@app.get("/recent")
def recent(limit: int = 10):
    _ensure_data_loaded()
    df = df_global
    if df is None or len(df) == 0:
        return {"matches": []}

    def _first_col(df, primary, alts):
        for c in (primary, *alts):
            if c in df.columns:
                return c
        return None

    colL = _first_col(df, "League", ["Div"])
    colH = _first_col(df, "HomeTeam", ["Home", "Home_Team"])
    colA = _first_col(df, "AwayTeam", ["Away", "Away_Team"])
    colHG = _first_col(df, "FTHG", ["HG", "HomeGoals", "Home_Goals"])
    colAG = _first_col(df, "FTAG", ["AG", "AwayGoals", "Away_Goals"])
    colD  = _first_col(df, "Date", ["MatchDate", "DateStr", "Fecha"])

    if not (colL and colH and colA):
        return {"matches": []}

    dfx = df[[c for c in [colD, colL, colH, colA, colHG, colAG] if c in df.columns]].copy()
    if colD in dfx.columns:
        dfx["_d"] = pd.to_datetime(dfx[colD], errors="coerce", dayfirst=True)
    else:
        dfx["_d"] = pd.NaT

    dfx = dfx.sort_values("_d", ascending=False).head(int(limit))

    rows = []
    for _, r in dfx.iterrows():
        rows.append({
            "Date": (r["_d"].strftime("%Y-%m-%d") if pd.notnull(r["_d"]) else str(r.get(colD, ""))),
            "League": str(r.get(colL, "")),
            "HomeTeam": str(r.get(colH, "")),
            "AwayTeam": str(r.get(colA, "")),
            "FTHG": (None if colHG not in dfx.columns or pd.isna(r.get(colHG)) else int(r.get(colHG))),
            "FTAG": (None if colAG not in dfx.columns or pd.isna(r.get(colAG)) else int(r.get(colAG))),
        })
    return {"matches": rows}

@app.get("/leagues")
def leagues():
    try:
        _ensure_data_loaded()
        df = df_global
        if df is None or len(df) == 0:
            return {"leagues": [], "note": "df_global vac√≠o"}

        def _first_col(df, primary, alts):
            for c in (primary, *alts):
                if c in df.columns:
                    return c
            return None

        colL = _first_col(df, "League", ["Div"])
        if not colL:
            return {"leagues": [], "note": "No se encontr√≥ columna League/Div"}

        lgs = sorted(str(x) for x in df[colL].dropna().unique())
        return {"leagues": lgs}
    except Exception as e:
        print("[/leagues] ERROR:", repr(e))
        return JSONResponse(status_code=200, content={"leagues": [], "error": str(e)})

@app.get("/teams")
def teams(league: Optional[str] = Query(None, description="C√≥digo liga: ej E0, SP1, I1")):
    _ensure_data_loaded()
    df = df_global
    if df is None:
        return {"league": league, "teams": []}

    def _first_col(df, primary, alts):
        for c in (primary, *alts):
            if c in df.columns:
                return c
        return None

    colL = _first_col(df, "League", ["Div"])
    if league and colL:
        df = df[df[colL] == league]
    home_col = _first_col(df, "HomeTeam", ["Home", "Home_Team"])
    away_col = _first_col(df, "AwayTeam", ["Away", "Away_Team"])
    if not home_col or not away_col:
        return {"league": league, "teams": []}
    homes = set(df[home_col].dropna().astype(str).unique())
    aways = set(df[away_col].dropna().astype(str).unique())
    all_teams = sorted(list(homes.union(aways)))
    return {"league": league, "teams": all_teams}

@app.get("/health")
def health():
    _ensure_data_loaded()
    df = df_global
    if df is None:
        return {"status": "empty", "teams": []}

    def _first_col(df, primary, alts):
        for c in (primary, *alts):
            if c in df.columns:
                return c
        return None

    home_col = _first_col(df, "HomeTeam", ["Home", "Home_Team"])
    away_col = _first_col(df, "AwayTeam", ["Away", "Away_Team"])
    if not home_col or not away_col:
        return {"status": "ok", "teams": []}
    homes = set(df[home_col].dropna().astype(str).unique())
    aways = set(df[away_col].dropna().astype(str).unique())
    all_teams = sorted(list(homes.union(aways)))
    return {"status": "ok", "teams": all_teams}

# ========= Predicci√≥n =========
def predict_match(df: pd.DataFrame, home: str, away: str, bundle_1x2):
    """Predicci√≥n combinada: Poisson base + ML si est√° disponible."""
    # Poisson
    res = model.predict(home, away)
    res["exp_goals_total"] = round(res["exp_goals_home"] + res["exp_goals_away"], 3)
    res["src_1x2"] = "poisson"
    res["src_ou25"] = "xg"
    res["src_btts"] = "poisson"

    # 1X2 por ML
    if bundle_1x2:
        Xy = _get_Xy()

        def prof(Xy, team, is_home):
            cols = [c for c in Xy.columns if c.startswith("H_" if is_home else "A_")]
            mask = (Xy["HomeTeam"] == team) if is_home else (Xy["AwayTeam"] == team)
            return Xy.loc[mask, cols].tail(5).median() if len(Xy.loc[mask, cols]) else pd.Series({c: 0.0 for c in cols})

        hp, ap = prof(Xy, home, True), prof(Xy, away, False)
        Elo_H = Xy.loc[Xy["HomeTeam"] == home, "Elo_H"].tail(1)
        Elo_A = Xy.loc[Xy["AwayTeam"] == away, "Elo_A"].tail(1)
        if len(Elo_H) == 0: Elo_H = pd.Series([Xy["Elo_H"].median()])
        if len(Elo_A) == 0: Elo_A = pd.Series([Xy["Elo_A"].median()])

        row = pd.DataFrame([{
            "Elo_H": float(Elo_H.values[-1]), "Elo_A": float(Elo_A.values[-1]),
            **{k: float(v) for k, v in hp.items()},
            **{k: float(v) for k, v in ap.items()},
        }])
        feats = bundle_1x2["features"]
        row = row.reindex(columns=feats).fillna(row.median(numeric_only=True))
        probs = bundle_1x2["model"].predict_proba(row)[0]  # [p_away, p_draw, p_home]
        res["p_away"], res["p_draw"], res["p_home"] = map(lambda x: round(float(x), 4), probs)
        res["src_1x2"] = "ml"

    # OU 2.5
    xt = res.get("exp_goals_total")
    if clf_ou_bundle:
        try:
            Xy = _get_Xy()
            def _prof_ou(Xy, team, is_home):
                cols = [c for c in Xy.columns if c.startswith("H_" if is_home else "A_")]
                mask = (Xy["HomeTeam"] == team) if is_home else (Xy["AwayTeam"] == team)
                if mask.any():
                    return Xy.loc[mask, cols].tail(5).median()
                return pd.Series({c: 0.0 for c in cols})
            hp, ap = _prof_ou(Xy, home, True), _prof_ou(Xy, away, False)
            Elo_H = Xy.loc[Xy["HomeTeam"] == home, "Elo_H"].tail(1)
            Elo_A = Xy.loc[Xy["AwayTeam"] == away, "Elo_A"].tail(1)
            if len(Elo_H) == 0: Elo_H = pd.Series([Xy["Elo_H"].median()])
            if len(Elo_A) == 0: Elo_A = pd.Series([Xy["Elo_A"].median()])
            row_ou = pd.DataFrame([{
                "Elo_H": float(Elo_H.values[-1]), "Elo_A": float(Elo_A.values[-1]),
                **{k: float(v) for k, v in hp.items()},
                **{k: float(v) for k, v in ap.items()},
            }])
            feats_ou = clf_ou_bundle["features"]
            row_ou = row_ou.reindex(columns=feats_ou).fillna(row_ou.median(numeric_only=True))
            p_over = float(clf_ou_bundle["model"].predict_proba(row_ou)[0, 1])
            res["ou_over25"] = round(p_over, 4)
            res["ou_under25"] = round(1.0 - p_over, 4)
            res["src_ou25"] = "ml"
        except Exception as e:
            p_over = 1.0 / (1.0 + math.exp(-1.1 * (xt - 2.5)))
            res["ou_over25"] = round(p_over, 4)
            res["ou_under25"] = round(1.0 - p_over, 4)
            res["src_ou25"] = "xg"
            print("[WARN] OU ML fallback por error:", repr(e))
    else:
        p_over = 1.0 / (1.0 + math.exp(-1.1 * (xt - 2.5)))
        res["ou_over25"] = round(p_over, 4)
        res["ou_under25"] = round(1.0 - p_over, 4)
        res["src_ou25"] = "xg"

    # BTTS
    if clf_btts_bundle:
        try:
            Xy = _get_Xy()
            def _prof_bt(Xy, team, is_home):
                cols = [c for c in Xy.columns if c.startswith("H_" if is_home else "A_")]
                mask = (Xy["HomeTeam"] == team) if is_home else (Xy["AwayTeam"] == team)
                if mask.any():
                    return Xy.loc[mask, cols].tail(5).median()
                return pd.Series({c: 0.0 for c in cols})
            hp, ap = _prof_bt(Xy, home, True), _prof_bt(Xy, away, False)
            Elo_H = Xy.loc[Xy["HomeTeam"] == home, "Elo_H"].tail(1)
            Elo_A = Xy.loc[Xy["AwayTeam"] == away, "Elo_A"].tail(1)
            if len(Elo_H) == 0: Elo_H = pd.Series([Xy["Elo_H"].median()])
            if len(Elo_A) == 0: Elo_A = pd.Series([Xy["Elo_A"].median()])
            row_bt = pd.DataFrame([{
                "Elo_H": float(Elo_H.values[-1]), "Elo_A": float(Elo_A.values[-1]),
                **{k: float(v) for k, v in hp.items()},
                **{k: float(v) for k, v in ap.items()},
            }])
            feats_bt = clf_btts_bundle["features"]
            row_bt = row_bt.reindex(columns=feats_bt).fillna(row_bt.median(numeric_only=True))
            p_yes = float(clf_btts_bundle["model"].predict_proba(row_bt)[0, 1])
            res["btts_yes"] = round(p_yes, 4)
            res["btts_no"]  = round(1.0 - p_yes, 4)
            res["src_btts"] = "ml"
        except Exception as e:
            lam_h = float(res.get("exp_goals_home", 0.0))
            lam_a = float(res.get("exp_goals_away", 0.0))
            p_yes = (1 - math.exp(-lam_h)) * (1 - math.exp(-lam_a))
            res["btts_yes"] = round(p_yes, 4)
            res["btts_no"]  = round(1.0 - p_yes, 4)
            res["src_btts"] = "poisson"
            print("[WARN] BTTS ML fallback por error:", repr(e))
    else:
        lam_h = float(res.get("exp_goals_home", 0.0))
        lam_a = float(res.get("exp_goals_away", 0.0))
        p_yes = (1 - math.exp(-lam_h)) * (1 - math.exp(-lam_a))
        res["btts_yes"] = round(p_yes, 4)
        res["btts_no"]  = round(1.0 - p_yes, 4)
        res["src_btts"] = "poisson"

    # Extras: c√≥rners/amarillas/rojas/distrib. goles
    df = df_global
    eh = float(res.get("exp_goals_home", 0.0))
    ea = float(res.get("exp_goals_away", 0.0))
    et = float(res.get("exp_goals_total", eh + ea)) or (eh + ea)
    share_h = 0.5 if et <= 1e-9 else max(0.15, min(0.85, eh / et))

    exp_ch = exp_ca = exp_ct = over95 = under95 = None
    if df is not None and _col_ok(df, "HC") and _col_ok(df, "AC"):
        exp_ch = _recent_mean_home(df, home, "HC", n=10)
        exp_ca = _recent_mean_away(df, away, "AC", n=10)
        exp_ct = _sum_opt(exp_ch, exp_ca)
    else:
        exp_ct = max(6.0, min(15.0, 4.2 + 2.6 * et))
        exp_ch = exp_ct * share_h
        exp_ca = exp_ct * (1.0 - share_h)
    cdf9 = _poisson_cdf(9, exp_ct) if exp_ct is not None else None
    if cdf9 is not None:
        over95, under95 = max(0.0, min(1.0, 1.0 - cdf9)), max(0.0, min(1.0, cdf9))
    res["exp_corners_home"]  = round(exp_ch, 2) if exp_ch is not None else None
    res["exp_corners_away"]  = round(exp_ca, 2) if exp_ca is not None else None
    res["exp_corners_total"] = round(exp_ct, 2) if exp_ct is not None else None
    res["corners_over95"]    = round(over95, 4) if over95 is not None else None
    res["corners_under95"]   = round(under95, 4) if under95 is not None else None

    exp_yh = exp_ya = None
    if df is not None and _col_ok(df, "HY") and _col_ok(df, "AY"):
        exp_yh = _recent_mean_home(df, home, "HY", n=10)
        exp_ya = _recent_mean_away(df, away, "AY", n=10)
    else:
        base_y = max(2.5, min(7.0, 3.0 + 0.7 * et))
        exp_yh = base_y * (0.55 * share_h + 0.45 * (1 - share_h))
        exp_ya = base_y - exp_yh
    res["exp_yellows_home"] = round(exp_yh, 2) if exp_yh is not None else None
    res["exp_yellows_away"] = round(exp_ya, 2) if exp_ya is not None else None

    exp_rh = exp_ra = None
    if df is not None and _col_ok(df, "HR") and _col_ok(df, "AR"):
        exp_rh = _recent_mean_home(df, home, "HR", n=15)
        exp_ra = _recent_mean_away(df, away, "AR", n=15)
    else:
        ratio_r = 0.08
        exp_rh = ratio_r * (exp_yh or 0.0)
        exp_ra = ratio_r * (exp_ya or 0.0)
    res["exp_reds_home"] = round(exp_rh, 3) if exp_rh is not None else None
    res["exp_reds_away"] = round(exp_ra, 3) if exp_ra is not None else None

    lam = res.get("exp_goals_total", None)
    if lam is not None:
        p0 = _poisson_pmf(0, lam)
        p1 = _poisson_pmf(1, lam)
        p2 = _poisson_pmf(2, lam)
        if None not in (p0, p1, p2):
            res["p_goals_0"]     = round(p0, 4)
            res["p_goals_1"]     = round(p1, 4)
            res["p_goals_2"]     = round(p2, 4)
            res["p_goals_3plus"] = round(max(0.0, min(1.0, 1.0 - (p0 + p1 + p2))), 4)

    # Mejores marcadores (simple del Poisson home/away)
    max_g = 6
    def pois(lam_, k): return math.exp(-lam_) * (lam_**k) / math.factorial(k)
    pmf_h = np.array([pois(res["exp_goals_home"], k) for k in range(max_g+1)])
    pmf_a = np.array([pois(res["exp_goals_away"], k) for k in range(max_g+1)])
    mat = np.outer(pmf_h, pmf_a)
    flat = [((h,a), float(mat[h,a])) for h in range(max_g+1) for a in range(max_g+1)]
    flat.sort(key=lambda x: x[1], reverse=True)
    res["top_scorelines"] = [{"score": f"{h}-{a}", "p": round(p, 4)} for (h,a), p in flat[:5]]

    return res

@app.get("/predict", response_model=PredictResponse)
def predict(
    home: str = Query(..., description="Equipo local"),
    away: str = Query(..., description="Equipo visitante"),
    user: dict = Depends(user_required),
):
    start_total = time.time()
    _ensure_data_loaded()
    if df_global is None:
        raise HTTPException(status_code=500, detail="Dataset no cargado.")
    res = predict_match(df_global, home, away, clf_bundle)
    print(f"[PERF] Predicci√≥n {home} vs {away} tom√≥ {time.time()-start_total:.3f}s")
    return PredictResponse(**res)

# ========= Explicaciones =========
FEATURE_LABELS = {
    "Elo_H": "Elo Local","Elo_A": "Elo Visitante","H_r_GF": "F recientes (Local)","H_r_GA": "GA recientes (Local)",
    "H_r_GD": "GD recientes (Local)","H_r_W": "Racha victorias (Local)","H_r_D": "Racha empates (Local)",
    "H_r_L": "Racha derrotas (Local)","H_r_HomeRate":"Fortaleza en casa","A_r_GF": "GF recientes (Visita)",
    "A_r_GA": "GA recientes (Visita)","A_r_GD": "GD recientes (Visita)","A_r_W": "Racha victorias (Visita)",
    "A_r_D": "Racha empates (Visita)","A_r_L": "Racha derrotas (Visita)","A_r_HomeRate":"Rend. visitante",
}
def top_drivers(row: pd.DataFrame, feature_list: list[str], k: int = 3):
    colz = [c for c in feature_list if c in row.columns]
    if not colz: return []
    vals = row[colz].iloc[0]
    med = np.median(vals.values)
    mad = np.median(np.abs(vals.values - med)) or 1.0
    score = (vals - med) / mad
    idx = np.argsort(-np.abs(score.values))[:k]
    out = []
    for i in idx:
        feat = colz[i]; s = score.values[i]
        pretty = FEATURE_LABELS.get(feat, feat)
        arrow = "‚Üë" if s > 0 else "‚Üì"
        out.append(f"{pretty} {arrow}")
    return out

@app.get("/explain")
def explain(
    home: str = Query(..., description="Equipo local"),
    away: str = Query(..., description="Equipo visitante"),
    user: dict = Depends(user_required),
):
    _ensure_data_loaded()
    Xy = _get_Xy()
    if Xy is None or Xy.empty:
        raise HTTPException(status_code=500, detail="Features no disponibles a√∫n.")

    def team_prof(Xy: pd.DataFrame, team: str, is_home: bool) -> pd.Series:
        cols = [c for c in Xy.columns if c.startswith("H_" if is_home else "A_")]
        mask = (Xy["HomeTeam"] == team) if is_home else (Xy["AwayTeam"] == team)
        if mask.any():
            return Xy.loc[mask, cols].tail(5).median(numeric_only=True)
        return pd.Series({c: 0.0 for c in cols}, dtype="float64")

    hp, ap = team_prof(Xy, home, True), team_prof(Xy, away, False)

    Elo_H = Xy.loc[Xy["HomeTeam"] == home, "Elo_H"].tail(1)
    Elo_A = Xy.loc[Xy["AwayTeam"] == away, "Elo_A"].tail(1)
    if len(Elo_H) == 0: Elo_H = pd.Series([Xy["Elo_H"].median(numeric_only=True)])
    if len(Elo_A) == 0: Elo_A = pd.Series([Xy["Elo_A"].median(numeric_only=True)])

    base_row = pd.DataFrame([{
        "Elo_H": float(Elo_H.values[-1]), "Elo_A": float(Elo_A.values[-1]),
        **{k: float(v) for k, v in hp.items()},
        **{k: float(v) for k, v in ap.items()},
    }])

    expl = {"home": home, "away": away, "reasons": {}}
    if clf_bundle and "features" in clf_bundle:
        feats = clf_bundle["features"]
        row = base_row.reindex(columns=feats).fillna(base_row.median(numeric_only=True))
        expl["reasons"]["1x2"] = top_drivers(row, feats, 3)
    else:
        expl["reasons"]["1x2"] = ["Poisson por xG de ambos"]

    if clf_ou_bundle and "features" in clf_ou_bundle:
        feats = clf_ou_bundle["features"]
        row = base_row.reindex(columns=feats).fillna(base_row.median(numeric_only=True))
        expl["reasons"]["ou25"] = top_drivers(row, feats, 3)
    else:
        expl["reasons"]["ou25"] = ["xG total vs 2.5"]

    if clf_btts_bundle and "features" in clf_btts_bundle:
        feats = clf_btts_bundle["features"]
        row = base_row.reindex(columns=feats).
